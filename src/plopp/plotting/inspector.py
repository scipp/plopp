# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2023 Scipp contributors (https://github.com/scipp)

from typing import Literal

import numpy as np
import scipp as sc

from ..core import Node
from ..core.typing import Plottable
from ..core.utils import coord_as_bin_edges
from ..graphics import imagefigure, linefigure
from .common import preprocess, require_interactive_figure


def _to_bin_edges(da: sc.DataArray, dim: str) -> sc.DataArray:
    """
    Convert dimension coords to bin edges.
    """
    for d in set(da.dims) - {dim}:
        da.coords[d] = coord_as_bin_edges(da, d)
    return da


def _apply_op(da: sc.DataArray, op: str, dim: str) -> sc.DataArray:
    out = getattr(sc, op)(da, dim=dim)
    if out.name:
        out.name = f'{op} of {out.name}'
    return out


def _slice_xy(da: sc.DataArray, xy: dict[str, dict[str, int]]) -> sc.DataArray:
    x = xy['x']
    y = xy['y']
    return da[y['dim'], y['value']][x['dim'], x['value']]


def _coord_to_centers(da: sc.DataArray, dim: str) -> sc.Variable:
    coord = da.coords[dim]
    if da.coords.is_edges(dim, dim=dim):
        return sc.midpoints(coord, dim=dim)
    return coord


def _mask_outside_polygon(
    da: sc.DataArray, poly: dict[str, dict[str, sc.Variable]]
) -> sc.DataArray:
    from matplotlib.path import Path

    xdim = poly['x']['dim']
    ydim = poly['y']['dim']
    x = _coord_to_centers(da, xdim)
    y = _coord_to_centers(da, ydim)
    vx = poly['x']['value'].to(unit=x.unit).values
    vy = poly['y']['value'].to(unit=y.unit).values
    verts = np.column_stack([vx, vy])
    path = Path(verts)
    xx = sc.broadcast(x, sizes={**x.sizes, **y.sizes})
    yy = sc.broadcast(y, sizes={**x.sizes, **y.sizes})
    points = np.column_stack([xx.values.ravel(), yy.values.ravel()])
    inside = sc.array(
        dims=yy.dims, values=path.contains_points(points).reshape(yy.shape)
    )
    return da.assign_masks(__inside_polygon=~inside).sum({*x.dims, *y.dims})


def inspector(
    obj: Plottable,
    dim: str | None = None,
    *,
    aspect: Literal['auto', 'equal'] | None = None,
    autoscale: bool = True,
    cbar: bool = True,
    clabel: str | None = None,
    cmax: sc.Variable | float | None = None,
    cmin: sc.Variable | float | None = None,
    errorbars: bool = True,
    figsize: tuple[float, float] | None = None,
    grid: bool = False,
    legend: bool | tuple[float, float] = True,
    logc: bool | None = None,
    mask_cmap: str = 'gray',
    mask_color: str = 'black',
    mode: Literal['point', 'polygon'] = 'point',
    nan_color: str | None = None,
    norm: Literal['linear', 'log'] | None = None,
    operation: Literal['sum', 'mean', 'min', 'max'] = 'sum',
    orientation: Literal['horizontal', 'vertical'] = 'horizontal',
    title: str | None = None,
    vmax: sc.Variable | float | None = None,
    vmin: sc.Variable | float | None = None,
    xlabel: str | None = None,
    xmax: sc.Variable | float | None = None,
    xmin: sc.Variable | float | None = None,
    ylabel: str | None = None,
    ymax: sc.Variable | float | None = None,
    ymin: sc.Variable | float | None = None,
    **kwargs,
):
    """
    Inspector takes in a three-dimensional input and applies a reduction operation
    (``'sum'`` by default) along one of the dimensions specified by ``dim``.
    It displays the result as a two-dimensional image.
    In addition, an 'inspection' tool is available in the toolbar. In ``mode='point'``
    it allows placing point markers on the image to slice at that position, retaining
    only the third dimension and displaying the resulting one-dimensional slice in the
    right-hand side figure. In ``mode='polygon'`` it allows drawing a polygon to compute
    the total intensity inside the polygon as a function of the third dimension.

    Controls (point mode):
    - Left-click to make new points
    - Left-click and hold on point to move point
    - Middle-click to delete point

    Controls (polygon mode):
    - Left-click to make new polygons
    - Left-click and hold on polygon vertex to move vertex
    - Right-click and hold to drag/move the entire polygon
    - Middle-click to delete polygon

    Notes
    -----

    Almost all the arguments for plot customization apply to the two-dimensional image
    (unless specified).

    Parameters
    ----------
    obj:
        The object to be plotted.
    dim:
        The dimension along which to apply the reduction operation. This will also be
        the dimension that remains in the one-dimensional slices generated by adding
        markers on the image. If no dim is provided, the last (inner) dim of the input
        data will be used.
    aspect:
        Aspect ratio for the axes.
    autoscale:
        Automatically scale the axes/colormap on updates if ``True``.
    cbar:
        Show colorbar if ``True``.
    clabel:
        Label for colorscale.
    cmax:
        Upper limit for colorscale.
    cmin:
        Lower limit for colorscale.
    errorbars:
        Show errorbars if ``True`` (1d figure).
    figsize:
        The width and height of the figure, in inches.
    grid:
        Show grid if ``True``.
    legend:
        Show legend if ``True``. If ``legend`` is a tuple, it should contain the
        ``(x, y)`` coordinates of the legend's anchor point in axes coordinates
        (1d figure).
    logc:
        If ``True``, use logarithmic scale for colorscale.
    mask_cmap:
        Colormap to use for masks.
    mask_color:
        Color of masks (overrides ``mask_cmap``).
    mode:
        Select ``'point'`` for point inspection or ``'polygon'`` for polygon selection
        with total intensity inside the polygon plotted as a function of ``dim``.
    nan_color:
        Color to use for NaN values.
    norm:
        Set to ``'log'`` for a logarithmic colorscale. Legacy, prefer ``logc`` instead.
    operation:
        The operation to apply along the third (undisplayed) dimension specified by
        ``dim``.
    orientation:
        Display the two panels side-by-side ('horizontal') or one below the other
        ('vertical').
    title:
        The figure title.
    vmax:
        Upper limit for data colorscale to be displayed.
        Legacy, prefer ``cmax`` instead.
    vmin:
        Lower limit for data colorscale to be displayed.
        Legacy, prefer ``cmin`` instead.
    xlabel:
        Label for x-axis.
    xmax:
        Upper limit for x-axis (1d figure)
    xmin:
        Lower limit for x-axis (1d figure)
    ylabel:
        Label for y-axis.
    ymax:
        Upper limit for y-axis (1d figure).
    ymin:
        Lower limit for y-axis (1d figure).
    **kwargs:
        Additional arguments forwarded to the underlying plotting library.

    Returns
    -------
    :
        A :class:`Box` which will contain two :class:`Figure` and one slider widget.
    """

    f1d = linefigure(
        autoscale=autoscale,
        errorbars=errorbars,
        grid=grid,
        legend=legend,
        mask_color=mask_color,
        xmax=xmax,
        xmin=xmin,
        ymax=ymax,
        ymin=ymin,
    )
    require_interactive_figure(f1d, 'inspector')

    in_node = Node(preprocess, obj, ignore_size=True)
    data = in_node()
    if data.ndim != 3:
        raise ValueError(
            'The inspector plot currently only works with '
            f'three-dimensional data, found {data.ndim} dims.'
        )
    if dim is None:
        dim = data.dims[-1]
    bin_edges_node = Node(_to_bin_edges, in_node, dim=dim)
    op_node = Node(_apply_op, da=bin_edges_node, op=operation, dim=dim)
    f2d = imagefigure(
        op_node,
        aspect=aspect,
        cbar=cbar,
        clabel=clabel,
        cmax=cmax,
        cmin=cmin,
        figsize=figsize,
        grid=grid,
        logc=logc,
        mask_cmap=mask_cmap,
        mask_color=mask_color,
        nan_color=nan_color,
        norm=norm,
        title=title,
        vmax=vmax,
        vmin=vmin,
        xlabel=xlabel,
        ylabel=ylabel,
        **kwargs,
    )
    from ..widgets import Box, PointsTool, PolygonTool

    if mode == 'point':
        tool = PointsTool(
            figure=f2d,
            input_node=bin_edges_node,
            func=_slice_xy,
            destination=f1d,
            tooltip="Activate inspector tool",
        )
    elif mode == 'polygon':
        tool = PolygonTool(
            figure=f2d,
            input_node=bin_edges_node,
            func=_slice_inside_polygon,
            destination=f1d,
            tooltip="Activate polygon inspector tool",
        )
    else:
        raise ValueError(f'Mode "{mode}" is unknown.')

    f2d.toolbar['inspect'] = tool
    out = [f2d, f1d]
    if orientation == 'horizontal':
        out = [out]
    return Box(out)
